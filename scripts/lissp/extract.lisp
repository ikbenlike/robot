(defun whitespace-p (c)
  (cond ((char= c #\space) t)
        ((char= c #\tab) t)
        ((char= c #\linefeed) t)
        ((char= c #\return) t)
        (t nil)))

(defun read-entire-file (path)
  (with-open-file (stream path)
    (let ((contents (make-string (file-length stream))))
      (read-sequence contents stream)
      contents)))

(defun extract-x (text)
  (let* ((index (search "which=\"X\">" text))
         (l (length "which=\"X\">"))
         (data (subseq text (+ l index)))
         (i 0))
    (loop :for x := (char data i)
          :do (setq i (1+ i))
          :if (char= x #\<)
          :return (subseq data 0 (1- i)))))

(defun extract-y (text)
  (let* ((index (search "which=\"Y\">" text))
         (l (length "which=\"Y\">"))
         (data (subseq text (+ l index)))
         (i 0))
    (loop :for x := (char data i)
          :do (setq i (1+ i))
          :if (char= x #\<)
          :return (subseq data 0 (1- i)))))

(defun extract-direction (text)
  (let ((index (search "<direction>" text))
        (l (length "<direction>"))
        (str (make-string 2)))
    (setf (char str 0) (char text (+ index l)))
    (setf (char str 1) (char text (+ index 1 l)))
    str))

(if (string-equal (nth 1 *posix-argv*) "X")
    (princ (extract-x (read-entire-file "data/data.xml")))
    (if (string-equal (nth 1 *posix-argv*) "Y")
        (princ (extract-y (read-entire-file "data/data.xml")))
        (princ (extract-direction (read-entire-file "data/data.xml")))))
